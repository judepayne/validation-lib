# validation-lib-py

Python business data validation library with dynamic rule loading.

## Overview

validation-lib-py provides a flexible validation framework for business data. It is built on the assumption that data is expressed as JSON, and that there are JSON Schemas available to validate the data against. Validation rules however extend far beyond schema validation. A rule can be any arbitrary python with two constraints:
- A rule must be a Python class that conforms to the interface defined in logic/rules/base.py
- Rule code should use the relevant entity_helper class to access data in the fields it's being applied to. This helps track dependencies between rule versions and the fields they depend on, as well as create a logical separation between the two to reduce brittleness.

The `logic\` folder is where all the business logic lives; i.e. the rules themselves, the entity_helpers, the JSON schemas and the business-config.yaml file that binds it all together. Although the logic\ folder and its contents are provided as working examples in this library, in production the logic folder would most probably live somewhere else and be maintained by a different (Business) team, whereas the rest of this library is to considered a Technology asset.
The location of the `logic\` folder is specified by a parameter in local-config.yaml (which always lives with the library). This indirection is what would allow `logic\` to reside somewhere else in Production. Its production location can be specified as a file path or a url.

In `logic\business-config.yaml`, rules are grouped into **rulesets** and when the user of the library wants to validate a piece of business data, for example a loan, then would call the validate function in the library's api, specifying the ruleset name. As well as one off validation, the library offers batch validation functionality, and functions to explore the available rulesets and dig into a specific ruleset and its setup.

This library is designed to be embedded in multiple applications, e.g. business applications, web apps, mcp-servers etc. Since its use could be widespread across an organization's environment, it has functionality to force refresh of the `logic` that all instances of the library will use. This is explained more further down in this README.

### Features

- **Dynamic rule loading** - Load validation rules from local paths or remote URLs
- **Two-tier configuration** - Separate infrastructure config from business logic
- **JSON Schema validation** - First-class schema support
- **Custom Python rules** - Write business rules in Python
- **Entity helpers** - Logical field abstraction layer
- **Hot reload** - Update logic without restarting

This library is nearly Prod ready. Furthter down in this README are thoughts on next steps towards full productionization.


## Installation

```bash
pip install git+https://github.com/judepayne/validation-lib-py.git
```

## Quick Start

```python
from validation_lib import ValidationService

# Initialize service (loads bundled config, fetches logic)
service = ValidationService()

# Validate an entity
results = service.validate("loan", {
    "$schema": "https://example.com/schemas/loan/v1.0.0",
    "id": "LOAN-001",
    "principal_amount": 100000,
    "interest_rate": 0.045,
    ...
}, "quick")

# Check results
for result in results:
    if result['status'] == 'FAIL':
        print(f"{result['rule_id']}: {result['message']}")
```

## API Reference

### ValidationService

Main entry point for all validation operations.

#### `__init__()`

Initialize service with bundled configuration.

```python
service = ValidationService()
```

#### `validate(entity_type, entity_data, ruleset_name)`

Validate a single entity.

**Parameters:**
- `entity_type` (str): Entity type (e.g., "loan", "facility")
- `entity_data` (dict): Entity data with `$schema` field
- `ruleset_name` (str): Ruleset to use (e.g., "quick", "thorough")

**Returns:** List of validation result dicts

**Example:**
```python
results = service.validate("loan", loan_data, "quick")
```

#### `discover_rules(entity_type, entity_data, ruleset_name)`

Discover available rules for an entity type.

**Returns:** Dict mapping rule_id to rule metadata

**Example:**
```python
rules = service.discover_rules("loan", sample_data, "quick")
for rule_id, metadata in rules.items():
    print(f"{rule_id}: {metadata['description']}")
    print(f"  Fields: {metadata['field_dependencies']}")
```

#### `discover_rulesets()`

Discover all available rulesets.

**Returns:** Dict mapping ruleset_name to ruleset metadata and stats

**Example:**
```python
rulesets = service.discover_rulesets()
for name, info in rulesets.items():
    print(f"{name}: {info['metadata']['description']}")
    print(f"  Rules: {info['stats']['total_rules']}")
```

#### `batch_validate(entities, id_fields, ruleset_name)`

Validate multiple entities.

**Parameters:**
- `entities` (list): List of entity dicts
- `id_fields` (list): Field names for entity identification
- `ruleset_name` (str): Ruleset to use

**Returns:** List of per-entity validation results

**Example:**
```python
results = service.batch_validate([loan1, loan2, loan3], ["id"], "quick")
```

#### `batch_file_validate(file_uri, entity_types, id_fields, ruleset_name)`

Validate entities from a file.

**Parameters:**
- `file_uri` (str): File URI (file://, http://, https://)
- `entity_types` (list): Entity types in file
- `id_fields` (list): Field names for entity identification
- `ruleset_name` (str): Ruleset to use

**Returns:** List of validation results

**Example:**
```python
results = service.batch_file_validate(
    "file:///data/loans.json",
    ["loan"],
    ["id"],
    "thorough"
)
```

#### `reload_logic()`

Reload business logic from source.

Clears cache and re-fetches all logic (config, rules, helpers).

**Example:**
```python
# In development - pick up local changes
service.reload_logic()

# In production - refresh from remote
if service.get_cache_age() > 3600:  # Older than 1 hour
    service.reload_logic()
```

#### `get_cache_age()`

Get age of cached logic in seconds.

**Returns:** Age in seconds, or None if not cached

**Example:**
```python
age = service.get_cache_age()
if age and age > 3600:  # 1 hour
    print(f"Cache is {age/3600:.1f} hours old")
    service.reload_logic()
```

## JSON-RPC Server (Multi-Language Support)

The library includes a JSON-RPC 2.0 server for use from other programming languages (Clojure, Java, Node.js, Go, etc.).

### Starting the Server

```bash
python -m validation_lib.jsonrpc_server [--debug]
```

The server reads JSON-RPC requests from stdin and writes responses to stdout (newline-delimited JSON).

### Stopping the Server

The server stops gracefully when:

- **EOF received on stdin** - Close the stdin pipe from the client
- **SIGTERM or SIGINT** - Send signal (e.g., Ctrl+C, `kill <pid>`)
- **Process termination** - Client terminates the subprocess

Example (Python):
```python
# Close stdin to trigger graceful shutdown
server.stdin.close()
server.wait()
```

### Protocol

**Request format:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "validate",
  "params": {
    "entity_type": "loan",
    "entity_data": {...},
    "ruleset_name": "quick"
  }
}
```

**Success response:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": [...]
}
```

**Error response:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32000,
    "message": "Error description"
  }
}
```

### Supported Methods

All ValidationService methods are available via JSON-RPC:

- `validate` - Validate single entity
- `discover_rules` - Discover available rules
- `discover_rulesets` - Discover all rulesets
- `batch_validate` - Validate multiple entities
- `batch_file_validate` - Validate entities from file
- `reload_logic` - Reload business logic
- `get_cache_age` - Get cache age in seconds

### Error Codes

- `-32700` - Parse error (invalid JSON)
- `-32600` - Invalid request (malformed JSON-RPC)
- `-32601` - Method not found
- `-32602` - Invalid parameters
- `-32000` - Internal application error

### Client Example (Python)

```python
import json
import subprocess

# Start server
server = subprocess.Popen(
    ["python", "-m", "validation_lib.jsonrpc_server"],
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    text=True
)

# Send request
request = {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "discover_rulesets",
    "params": {}
}
server.stdin.write(json.dumps(request) + "\n")
server.stdin.flush()

# Read response
response = json.loads(server.stdout.readline())
print(response["result"])
```

### Client Example (Clojure)

```clojure
(require '[clojure.java.shell :as shell]
         '[cheshire.core :as json])

(defn call-rpc [method params]
  (let [process (.. (ProcessBuilder. ["python" "-m" "validation_lib.jsonrpc_server"])
                    (start))
        request (json/generate-string
                  {:jsonrpc "2.0"
                   :id 1
                   :method method
                   :params params})]
    ;; Write request
    (.write (.getOutputStream process) (.getBytes (str request "\n")))
    (.flush (.getOutputStream process))

    ;; Read response
    (-> (.getInputStream process)
        (slurp)
        (json/parse-string true))))

(call-rpc "discover_rulesets" {})
```

## Configuration

The library uses a three-tier configuration system for flexibility across deployments:

### Tier 1: Local Configuration (bundled)

`validation_lib/local-config.yaml` - Infrastructure configuration

```yaml
# Points to business and coordination service configuration locations
business_config_uri: "../logic/business-config.yaml"
coordination_service_config_uri: "../coordination-service-config.yaml"
```

Each URI supports:
- **Relative paths**: `../logic/business-config.yaml` (development)
- **Absolute paths**: `/opt/validation/logic/business-config.yaml`
- **Remote URLs**: `https://rules-cdn.example.com/logic/business-config.yaml` (production)

This indirection allows:
- Central management of coordination service endpoints across deployments
- Different environments pointing to different coordination services
- Remote hosting of both business config and coordination service config

### Tier 2: Business Configuration

`logic/business-config.yaml` - Business logic configuration

Defines:
- Rulesets (quick, thorough, etc.) with metadata
- Rule assignments per schema version
- Schema-to-helper mappings
- Entity helper defaults

### Tier 3: Coordination Service Configuration

`logic/coordination-service-config.yaml` - Coordination service settings

```yaml
enabled: false                        # Enable coordination service calls
base_url: "http://localhost:8081"     # Coordination service endpoint
timeout_ms: 5000                      # Request timeout
retry_attempts: 3                     # Retry attempts on failure
circuit_breaker_enabled: false        # Circuit breaker (future)
```

Like business config, this file can be:
- **Local**: Development environments use local file
- **Remote**: Production environments point to centrally managed URL
- **Shared**: Multiple deployments share same coordination service config

## Auto-Refresh & Caching

### Automatic Config Refresh

The library automatically checks and reloads stale configurations to keep distributed instances synchronized:

**Refresh intervals:**
- Business config: Auto-reloads if older than **30 minutes**
- Coordination service config: Auto-reloads if older than **30 minutes**
- Check frequency: Every **5 minutes** (debounced to avoid overhead)

The freshness check happens automatically at the start of API calls (`validate()`, `discover_rules()`, etc.). This ensures:
- Active instances stay fresh with centralized config changes
- Minimal performance overhead (check only every 5 minutes)
- No background threads or complex infrastructure needed

**How it works:**
```python
service = ValidationService()

# First call: loads configs
service.validate(loan1, "quick")

# ... 35 minutes later ...

# This call triggers auto-reload (configs > 30 min old)
service.validate(loan2, "quick")  # Fresh configs automatically loaded
```

### Cache Directory

Logic and remote configs are cached in:

```
/tmp/validation-lib-py/logic/
/tmp/validation-lib-py/config_*.yaml
```

**Manual refresh:**
```python
service.reload_logic()  # Force immediate reload
```

**Cache age monitoring:**
```python
age = service.get_cache_age()
if age and age > 1800:  # 30 minutes
    print(f"Cache is {age/60:.0f} minutes old")
```

## Coordination Service

The validation framework supports cross-entity validation through a coordination service.

### Purpose

Many validation rules need data beyond the entity being validated:

- **Hierarchical checks**: Loan checking against parent facility limit
- **Cross-entity checks**: Facility verifying all child loans use same currency
- **Reference data**: Deal validating client credit rating freshness

### How It Works

**1. Rules declare required data** using vocabulary terms:

```python
def required_data(self):
    return ["parent"]  # Need parent entity data
```

**Vocabulary terms:**
- `parent` - Parent entity in hierarchy
- `all_children` - All child entities
- `all_siblings` - Sibling entities
- `client_reference_data` - Related client data
- `parent's_legal_document` - Parent's legal documents

**2. Validation workflow:**
1. ValidationService calls `engine.get_required_data()` to discover vocabulary terms
2. ValidationService calls `coordination_proxy.get_associated_data()` to fetch data
3. Coordination service (HTTP endpoint) returns associated data
4. ValidationEngine provides data to rules via `set_required_data()`
5. Rules execute with access to required data

### Integration

The library integrates with the coordination service via `CoordinationProxy`:

```python
# Internal - handled automatically by ValidationService
coordination_proxy = CoordinationProxy(config)
required_data = coordination_proxy.get_associated_data(
    entity_type="loan",
    entity_data={...},
    vocabulary_terms=["parent", "all_children"]
)
```

The coordination service is a web application with JSON endpoints:

**Request to `/fetch-data`:**
```json
{
  "entity_type": "loan",
  "entity_data": {...},
  "vocabulary_terms": ["parent", "all_children"]
}
```

**Response:**
```json
{
  "parent": {...},
  "all_children": [{...}, {...}]
}
```

### Configuration

The coordination service config is loaded from a separate file referenced in `local-config.yaml`:

```yaml
# local-config.yaml
coordination_service_config_uri: "../coordination-service-config.yaml"
```

This URI can point to:
- Local file (development): `../coordination-service-config.yaml`
- Remote URL (production): `https://config.example.com/coordination-service-config.yaml`

**coordination-service-config.yaml:**
```yaml
enabled: false                        # Set to true when coordination service available
base_url: "http://localhost:8081"     # Coordination service endpoint
timeout_ms: 5000                      # Request timeout
retry_attempts: 3                     # Retry attempts on failure
circuit_breaker_enabled: false        # Circuit breaker (future)
```

This indirection allows:
- Multiple deployments sharing same coordination service config via remote URL
- Different environments (dev/staging/prod) pointing to different coordination services
- Central management of coordination service endpoints

### Current Status

**POC Phase**: `enabled: false` - Coordination proxy returns empty data. Rules requiring external data will return NORUN status.

**Production**: Update `coordination-service-config.yaml` with `enabled: true` and production endpoint. The service will fetch hierarchical relationships, reference data, and temporal data as needed.

This architecture separates data fetching from validation logic, keeping rules focused on business logic.

## Writing Validation Rules

Rules are Python classes in `logic/rules/<entity>/`:

```python
# logic/rules/loan/rule_002_v1.py
from core.base_rule import BaseRule

class Rule(BaseRule):
    def get_id(self):
        return "rule_002_v1"

    def validates(self):
        return "loan"

    def description(self):
        return "Loan must have positive principal"

    def required_data(self):
        return []  # No additional data needed

    def run(self, entity_helper, required_data_map):
        principal = entity_helper.principal  # Logical field access

        if principal <= 0:
            return self.fail(f"Principal must be positive, got {principal}")

        return self.success()
```

## Development

Install in editable mode:

```bash
git clone https://github.com/judepayne/validation-lib-py.git
cd validation-lib-py
pip install -e .
```

Run tests:

```bash
pytest
```

## Architecture

```
┌─────────────────────────────────┐
│   Your Application              │
│   (uses validation_lib)         │
└─────────────┬───────────────────┘
              │
              │ ValidationService API
              │
┌─────────────▼────────────────────┐
│   validation-lib-py              │
│   - Configuration loading        │
│   - Logic fetching/caching       │
│   - Rule loading & execution     │
│   - Validation orchestration     │
└────────┬─────────────────────────┘
         │
         │ (Future) Fetch required data
         │ (parent, children, reference data)
         │
┌────────▼─────────────────────────┐
│   Coordination Service           │
│   - Hierarchical relationships   │
│   - Reference data               │
│   - Temporal data                │
│   (Not yet implemented - stubbed)│
└──────────────────────────────────┘
```

## Production Considerations

This is a POC implementation. The following areas require attention for production deployment:

### 1. Coordination Service Implementation

**Current State:** Stubbed - returns empty data (`{}`)

**Production Requirements:**
- **Implement HTTP client** - Complete the HTTP POST implementation in `coordination_proxy.py`
  ```python
  # Currently commented out - needs implementation
  response = requests.post(
      f"{self.base_url}/fetch-data",
      json=payload,
      timeout=self.timeout_ms / 1000.0
  )
  ```
- **Add retry logic** - Implement exponential backoff for failed requests
- **Add circuit breaker** - Prevent cascading failures when coordination service is down
- **Error handling** - Gracefully handle timeouts, network errors, invalid responses
- **Fallback behavior** - Define what happens when coordination service unavailable (NORUN status for dependent rules?)

**Deployment Steps:**
1. Implement coordination service with `/fetch-data` endpoint
2. Complete HTTP client in `coordination_proxy.py`
3. Create production `coordination-service-config.yaml`
4. Host config remotely (CDN/config server)
5. Update `coordination_service_config_uri` in `local-config.yaml`
6. Set `enabled: true` in `coordination-service-config.yaml`
7. Tune `timeout_ms` and `retry_attempts` based on SLAs

**Auto-refresh:** The library automatically reloads configs every 30 minutes. When you update the remote config file, all distributed instances will pick up changes within 30 minutes without restarts.

### 2. Monitoring & Observability

**Current State:** Basic Python logging only

**Production Requirements:**

**Metrics Export:**
- Rule execution counts (by rule_id, status)
- Validation latency (p50, p95, p99)
- Config reload frequency and duration
- Coordination service call latency and error rates
- Cache hit/miss rates

**Suggested Implementation:**
```python
# Prometheus metrics example
from prometheus_client import Counter, Histogram

validation_counter = Counter('validation_total', 'Total validations', ['entity_type', 'ruleset'])
validation_duration = Histogram('validation_duration_seconds', 'Validation duration')
coordination_errors = Counter('coordination_errors_total', 'Coordination service errors')
```

**Structured Logging:**
- JSON log format for machine parsing
- Correlation IDs for request tracing
- Log levels: DEBUG (development), INFO (production), ERROR (always)

**Suggested Implementation:**
```python
import structlog

logger = structlog.get_logger()
logger.info("validation_completed",
           entity_type="loan",
           entity_id="LOAN-001",
           ruleset="quick",
           duration_ms=45,
           rules_executed=12,
           failures=2)
```

**Performance Timing:**
- Per-rule execution time (already captured in `execution_time_ms`)
- Total validation time
- Config loading time
- Coordination service call time

### 3. Configuration Enhancements

**Current State:** Hardcoded intervals, no environment overrides

**Production Requirements:**

**Configurable Auto-Refresh Intervals:**
```yaml
# local-config.yaml
auto_refresh:
  business_config_max_age_seconds: 1800      # 30 minutes
  coordination_config_max_age_seconds: 1800  # 30 minutes
  check_interval_seconds: 300                # 5 minutes
```

**Environment Variable Overrides:**
```python
# Allow environment variables to override config
VALIDATION_LIB_BUSINESS_CONFIG_URI=https://config.example.com/business-config.yaml
VALIDATION_LIB_COORDINATION_ENDPOINT=https://coord.example.com
VALIDATION_LIB_LOG_LEVEL=INFO
```

**Dynamic Configuration:**
- Hot-reload specific components without full restart
- Reload only coordination config (lighter than full reload)
- Reload only business config (lighter than full reload)

### 4. File Validation Testing

**Current State:** Local `file://` URIs tested

**Production Requirements:**
- **Test remote file URIs** - Add tests for `https://` URLs
- **Test large files** - Validate performance with 10k+ entities
- **Test file format validation** - Handle malformed JSON gracefully
- **Test timeout handling** - File download timeouts for remote files
- **Test memory efficiency** - Stream large files instead of loading entirely in memory

**Suggested Test Cases:**
```python
def test_batch_file_validate_remote_https():
    """Test with remote HTTPS URL."""
    results = service.batch_file_validate(
        "https://example.com/data/loans.json",
        ["loan"],
        ["id"],
        "quick"
    )

def test_batch_file_validate_large_file():
    """Test with 10,000+ entities."""
    # Generate large file, validate memory usage stays bounded
```

### 5. Packaging & Distribution

**Current State:** Install via `pip install -e .` (development mode)

**Production Requirements:**

**PyPI Publishing:**
```bash
# Build distribution
python setup.py sdist bdist_wheel

# Upload to PyPI
twine upload dist/*

# Install in production
pip install validation-lib-py
```

**Version Management Strategy:**
- Semantic versioning: `MAJOR.MINOR.PATCH`
- Version in `validation_lib/__init__.py` (currently `0.1.0`)
- CHANGELOG.md documenting changes
- Git tags for releases: `v1.0.0`, `v1.1.0`, etc.

**Dependency Pinning:**
```txt
# requirements.txt - pin exact versions for production
pyyaml==6.0.1
jsonschema==4.21.1
requests==2.31.0
```

**Compatibility Testing:**
- Test with Python 3.9, 3.10, 3.11, 3.12, 3.13
- Document minimum Python version in `setup.py`

### 6. Security & Authentication

**Production Requirements:**
- **Secure remote URLs** - HTTPS only, no HTTP
- **Authentication for coordination service** - API keys, OAuth tokens
- **Input validation** - Sanitize entity data to prevent injection attacks
- **Rate limiting** - Prevent abuse of validation API
- **Audit logging** - Who validated what, when

### 7. Performance Optimization

**Current State:** Synchronous, single-threaded

**Production Options:**
- **Async/await** - For I/O-bound operations (coordination service calls)
- **Connection pooling** - Reuse HTTP connections to coordination service
- **Rule caching** - Cache loaded rule modules
- **Parallel rule execution** - Execute independent rules concurrently
- **Batch optimization** - Bulk fetch coordination data for batch validations

### 8. Resilience & Error Recovery

**Production Requirements:**
- **Graceful degradation** - Continue validation when coordination service down
- **Retry policies** - Exponential backoff with jitter
- **Timeout tuning** - Per-operation timeouts (validation, coordination, file loading)
- **Health checks** - Expose `/health` endpoint showing system status
- **Disaster recovery** - Fallback to cached coordination data if service unavailable

### 9. Deployment Patterns

**Recommended Approaches:**

**As a Library:**
```python
# Embed in your application
from validation_lib import ValidationService
service = ValidationService()
```

**As a Service (JSON-RPC):**
```bash
# Run standalone JSON-RPC server
python -m validation_lib.jsonrpc_server

# Call from any language
curl -X POST -d '{"jsonrpc":"2.0","method":"validate",...}'
```

**Containerization:**
```dockerfile
FROM python:3.11-slim
COPY . /app
RUN pip install /app
CMD ["python", "-m", "validation_lib.jsonrpc_server"]
```

### Production Readiness Checklist

- ✅ Core validation logic complete
- ✅ Auto-refresh implemented (30 min)
- ✅ JSON-RPC server for multi-language support
- ✅ Comprehensive test coverage (59 tests)
- ✅ Configuration indirection (three-tier)
- ⚠️ Coordination service stubbed - needs HTTP implementation
- ⚠️ Monitoring/metrics - needs Prometheus export
- ⚠️ Structured logging - needs JSON format
- ⚠️ Remote file testing - needs https:// test cases
- ⚠️ PyPI packaging - needs publishing
- ⚠️ Security - needs authentication layer
- ⚠️ Performance - needs load testing

**Current Status:** Production-ready for POC deployment. Requires coordination service implementation and observability tooling for full production use.

## License

MIT © Jude Payne 2026
